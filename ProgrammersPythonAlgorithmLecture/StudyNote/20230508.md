# [Day 1]

## 목차

1. [알고리즘 문제 풀이 기본 자세](#알고리즘-문제-풀이-기본-자세)
2. [기초 자료형](#기초-자료형)
    - [숫자형](#숫자형)
    - [문자열](#문자열)
    - [불린형](#불린형)
    - [명시적 형변환](#명시적-형변환)
3. [출력](#출력)
4. [list의 활용](#list의-활용)
5. [변수](#변수)
6. [제어문과 반복문](#제어문과-반복문)
7. [연산자](#연산자)
    - [할당 연산자](#할당-연산자)
    - [산술 연산자](#산술-연산자)

<br>

## 알고리즘 문제 풀이 기본 자세
- 나중에 스터디를 하게 되면 ***주석을 엄청 자세하게 적는 것***이 좋음 → 문제풀이 보따리에 예시 있음
    - 문제를 보고 어떤 방법으로 해결해야 하는지 작성
    - 한줄한줄 오른쪽에 주석을 달아서 어떤 것인지 적기
    - 어떤 논리로 풀지(구조화 하는지)를 한글로 적고 이를 python이라는 언어로 번역한다고 생각하기
- **알고리즘 문제풀이 순서**
    1. `입력`    
        다양한 이슈가 있음
    2. `구조화`/`저장 방법`    
        입력받은 내용을 어떻게 저장할 것인지
    3. `처리 로직 설계`    
        저장한 것을 어떻게 사용할 것인지
    4. `출력`    
        입맛따라 출력하는 것이 어려움
- 문제를 보자마자 처리 로직을 생각하는 것보다 ***어떤 방식으로 구조화 할 것인지를 먼저 생각***하는것이 좋음    
    → 로직과 구조화는 밀접한 관계를 맺고 있기 때문!
- **알고리즘은 수학이 아닌 글을 쓰는 것! 글을 어떻게 쓰는지를 배우는 것**
    **기본적인 사유로부터 어떻게 코드를 짤 것인지를 고민하는 것**
***
<br>

## 기초 자료형
<img src="https://hackmd.io/_uploads/HJhWrWDEh.png" width=400>

### 왜 자료형을 나누어야 할까
> 파이썬의 자료형을 이용하여 세상의 데이터를 표현하고, 논리적으로 계산할 수 있기 때문!

현실의 자료는 다양한 자료형을 가지고 있고, 이를 모두 글자 형태로만 표현할 수는 없기 때문에 크게 **3가지 종류**(`문자`, `숫자`, `진리값`)로 나뉘게 됨

### 숫자형
- 정수형(Int): 음의 정수, 양의 정수, 0
    - `type()`로 자료형 확인 가능
    <img src="https://hackmd.io/_uploads/BycXQMvV2.png" width=200>
    
    ⚠️ 타입을 꼭 찍어보는 실습을 하는 것이 좋음
        
- 실수형(Float)
    - **처리방법을 잘 배워야 함**

### 문자열
- 입력을 덩어리로 받는 경우에 주로 사용 → 빈 문자열은 엄연히 문자열(공백) 자체로 존재함
#### Python은 어디까지 가능할까?
- `1 + True = 2` → `True`를 `1`로 강제 형변환
- `a` > `c` 문자열 비교도 가능
    - 특정 문자열은 ascii 코드로 구성되어 있어서 비교할 수 있음
    - List 내부에서는 sorting도 가능
    - `ord()`에 넣으면 ASCII 코드를 알 수 있음
- ***어디까지가 에러범위이고 아닌지를 아는 것이 중요***
### 불린형
- `if`문 뒤에는 `boolean` 타입이 오거나 `boolean` 타입이라고 평가될 수 있는 것이 옴
    `0, 0.0, '', []` 처럼 비어있음을 뜻하는 값은 모두 `False`로 취급
    아래의 표는 불린형이 아닌 자료형이 어떻게 불린형으로 평가되는지에 대한 표!
    | 데이터의 값 | Boolean |
    |:---:|:---:|
    | **0** | **False** |
    | 1 | True |
    | -1 | True |
    | **0.0** | **False** |
    | 1.5 | True |
    | **‘’** | **False** |
    | ‘Hello’ | True |
    | **[]** | **False** |
    | [1, 2, 3] | True |
- 어떤 자료구조를 평가했는데 `1`인 경우 `true`로 전환하는 것 ⇒ 강제 형변환도 가능
    - 뭔가 차있으면 `true`, 비어있으면 `false`

### 명시적 형변환
- ***의도적으로 타입을 변환***하는 것
- 문자를 무조건 숫자로 바꾸지는 못함
    - 에러가 나오면 어떤 에러인지를 알아야 함!
    - `value error`, `type error`, `index error`
- **왜 배워야 할까?**
    - 알고리즘 문제 풀 때 `input`이 들어오기 때문에!
    - `input`, 처리, `output`
        - `input()`
            사용자의 입력을 받는 것
    - 입력에 대한 '**딥**'한 이야기
        - 파이썬은 인터프리터 언어로 한줄 한줄 읽음
        - **입력과 출력은 방향성이 반대**
            - `출력`은 **코드라인**에 적혀있는데 **터미널에 출력**이 되고
            - `입력`은 **터미널에서 입력**받는데 **코드라인**으로 들어감
            - 입력은 코드를 넣으면 프로세스 제어권이 터미널으로 넘어감
                - **input을 만나면 우선 STOP**, 사용자가 입력하기 전까지 인터프리터는 해석을 할 수 없음
        - **입력을 어떤 걸로 주든간에 `str` 형태로** 받아짐, `list`로 주든 `int`로 주든!
            ex) `[1, 2]`를 입력으로 주어도 `“[1, 2]”`가 됨
    - **형변환은 입력을 가지고 연산과 같이 활용을 하는 경우 필요하게 됨!**
        `age = int(input("입력: "))`
        - 1.5는 `float`이므로 바로 `int`로 변경하지 못함
        - `"hi"`와 같은 문자열은 `value error`로 `int`로 변경하지 못함
        - 실수형도 정수형으로 바꿀 수 있음!
            - 소숫점 이하를 ‘`버림`’할 때 사용 → 이것은 ***형변환이 아닌 버림 연산***
        - **`String`** 은 **`dictionary`** 등 뭐든 ***다 변환 가능***

***
<br>

## 출력
- print의 기본 옵션은 개행 방식(`\n`)
    - 타자기의 escape 문자열 → 개행됨
    - `end` 속성을 통해 뒤에 옵션을 지정하여 변경할 수 있음
    - 가끔 답에 공백 문자열을 끝으로 해달라고 하는 경우가 있음
- 애스터리스크 args ⇒ argumant가 여러개 들어갈 수 있음 → 여러개 프린트 가능
    - 언배킹 연산자로도 쓰임

***
<br>

## list의 활용
- Python의 list는 자료형에 구애받지 않고 이것저것 담을 수 있음
- 현실의 문제를 파이썬에 도입해서 계산을 하게 된다면? 어떤 구조를 쓸까?
    - API를 호출했을 때의 자료형과 매우 흡사함
        ```python
        users = {
            'total_user': 3,
            'information': [
                    {'name': 'alex', 'age':3, 'license':True},
                    {'name': 'june', 'age':7, 'license':False},
                    {'name': 'peter', 'age':4, 'license':False}
            ]
        }
        ```
    - List 내부에 여러 Dictionary가 들어간 구조
⇒ ***현실의 자료***는 이처럼 ***여러 자료형을 섞어 쓰는 것으로 구현***할 수 있음
- List를 조작하는 방법
    - 데이터를 추가할 때는 `.append()`
    - 맨 끝에 데이터를 추가할 때는 `.pop()`
    - 맨 앞의 데이터를 뺄 때는 `.pop(인덱스번호)`
    - **이런거 왜 배워요?!**
        - 현실 생활의 데이터를 조작할 때 더 쉽게 조작하기 위함
- **Stack / Queue**
    - `후입선출`구조(`Stack`)
        - 실생활(총 쏘기, 크롬의 뒤로가기 버튼), 재고자산 관리에도 쓰임
            - 크롬의 뒤로가기를 예로 하면?
                페이지를 이동하면 `System Stack`이 생성(Python에서는 List로 구현) 페이지를 이동할 때마다 Stack에 쌓임 `.append()`
                
                뒤로가기 버튼을 누르는 순간 Stack에서 `.pop(0)`됨
                
                Stack 배워서 어따 씀? ⬆️ 일케 씀
            - DSF(미로찾기) 알고리즘에 쓰임
    - `선입선출`구조(`Queue`)
        - 줄서는 것
        - 들어올 때는 꽁무늬에서 들어옴 `.append()`
        - 자료가 나갈 때는 앞에서 나감 `.pop(0)`
        - 게임 대기열 큐 → **우선순위큐(조건이 붙은 큐)**
            - 유저들의 등급에 맞추어 우선순위를 배정
- 트리 자료구조도 List로 구현 가능
***
<br>

## 변수
- 변수는 객체의 메모리 값을 가르키는 주소의 값이다
    - 상자가 아니다!!!!
- 변수에는 로직이 들어가야 하지 값이 들어가서는 안 됨
- 할당 = 객체의 메모리 값을 가르키는 것
- 좋은 점
    - 변수는 데이터에 의미를 부여
        - 한 눈에 파악하기 좋음
            예) `stack: []`, `queue: []`, `tree: []ㅍ
        - 코드의 재사용성과 가독성을 높여줌
            변수를 통해 하나의 변수로 재사용하는 것이 좋음
- 식별자와 리터럴 → 할당 연산자의 왼쪽과 오른쪽
    - 예약어: 특정 이름을 미리 지정해둔 것
        built인 애들이 미리 가지고 있는 이름을 사용하면 override 되는 것 → type error가 발생
- LEGB 규칙

    <img src="https://hackmd.io/_uploads/BJfXwMPVn.png" width=500>
- 별자 작성 규칙은 코드를 작성하면서 외우게 됨
    - 첫 글자는 숫자 불가
    - 대소문자를 구분함
    - 띄어쓰기는 언더바
    - 예약어로 지을 수 없음
        - `str`, `int`, `print` …
    - 변수 이름으로 인해 디버깅 속도가 달라질 수 있으니 정성들여 짓자
- python은 무조건 재할당이 가능함
    - 인터프리터 언어이기 때문에 하나씩 봄 → 같은 이름을 썼다면 맨 마지막에 할당한 것이 최종값
- 동시 할당 가능
    - `x = y = 10`
    - `x, y = 10, 20`
- Swap code?
    - `x = 3, y = 4`인 경우 보통은 빈컵을 두고 하나를 비운 후 다른 하나를 넣고 컵에 담은 것을 나머지 하나에 부어줌
    - 하지만 파이썬은 한줄로 가능 `x, y = y, x`
***
<br>

## 제어문과 반복문
> 어떻게 쓸까?(로직)에 해당하는 부분
- if → 제어문
- for → 반복문/이동기
    - 파이썬의 이터레이터 특성 때문에 하나씩 뽑아올 수 있음
    - 하나씩 뚜껑 땄을 때 어떤 조건에 해당하면 이거 해라~ 를 if 제어문으로
    - 사용하다 보면 `O(n)` 빅오표기법에 해당하는 효율성 문제가 나옴
***
<br>

## 연산자
### 할당 연산자
- `=`
- 변수에 각기 다른 자료형을 담아 표현할 수 있음
- 변수의 이름을 ***잘*** 지어서 어떤 자료형이 담겨있는지 알 수 있도록 해야 함
#### 할당 연산자는 왜 쓸까?
- 컴퓨터에는 메모리가 있음 컴퓨터의 경우 `10 + 20`을 30으로 저장하는 것이 아닌 `10`, `20`을 따로 저장하고 있는 ***메모리 주소값***이 있음
    - `id(변수명)`이 메모리 주소값을 볼 수 있는 메서드
- runtime context?
    - 파이썬은 인터프리터 언어로 한줄 한줄 해석하게 됨
    - 변수는 개발자들에게 메모리에 직접 접근/제어하는 것을 막기 위해서
    - 돌리는 환경에 따라 다른 주소값을 갖게 됨
    - 주소값을 변수에 할당하는 것
    - ***할당 연산자를 쓰는 이유는 타인의 컴퓨터를 망치지 않기 위해…!***
- 정확히 말하면 박스 담는 것이 아니라 화살표로 가르키는 것, ***왼쪽에 있는 애가 오른쪽에 있는 애를 가리킨다로 이해해야 함!***
- **예시코드**
    - `==`는 단순히 값을 비교하고 `is`는 메모리 주소값을 비교하게 됨
    - `a`와 `b`의 주소값이 다르므로 **`False`**
    
    <img src="https://hackmd.io/_uploads/ry9xhbw43.png" width=150>
    
    - `c`와 `a`의 주소값이 같으므로 **`True`**
    
    <img src="https://hackmd.io/_uploads/HkYWnbPVh.png" width=150>
    
    여기서 `c`는 `a`의 값을 ***포인팅*** 함, 객체 주소값을 함께 따라 가르키는 것으로 `a`를 바꾸면 `c`도 바뀌게 됨
    - [Python tutor](https://pythontutor.com/)에서 Edit this code하면 간단하게 파이썬을 돌려볼 수 있고, 시각적으로 확인할 수 있어서 개념을 이해하기에 많은 도움이 됨
    
    <img src="https://hackmd.io/_uploads/Syn0hbPNh.png" width=400>

### 산술 연산자
- 몫, 나머지, 제곱
- **저런거 대체 어따씀?**
    - 파이썬으로 `tree`를 어떻게 구현하는가?
    
        ![](https://hackmd.io/_uploads/S1v6ufv4h.png)
        
        - **위계질서**가 존재
        - 노드(Vertex, V)와 간선(Edge, E)으로 구성
        - 트리는 무조건 노드 갯수보다 간선 갯수가 하나 부족함
            - 루트 노드는 머리카락이 없으니까!
        - 상위 노드를 ***부모***(`P`)로 하위 노드를 ***자식***(`C`)으로
        - 자식이 둘뿐인 것 = 이진트리
        - 위의 경우`[-, 2, 7, 5, 2, 6, 9, 5, 11, 4]`
        - 자료에 규칙성이 존재해야 함
        - 부모자식간 명확한 index 규칙이 존재함
            - left child로 갈 때는 `* 2`
            - right child로 갈 땐 `* 2 + 1`
            - parent로 갈 때는  `// 2` (2로 나눈 몫)
- **정수 0으로 다른 수를 나누게 되면 ZeroDivisionError가 발생**
- `4 / 2`가 왜 2.0일까?
    - 컴퓨터는 10진법을 어떻게 2진법으로 저장하는가?!
        - 첫 칸은 +, -
        - 정수부
        - 소수부
        - **부동소수점 연산때문에 10진법을 올바르게 저장할 수 없어서 오차가 발생함 → 이로 인하여 float값이 되는 것**
        - 정확히 취하려면 `4 // 2`를 하는 것이 좋음
- Python은 에러가 많이 나는 언어라서 알고리즘을 풀기 좋음!
- 프로그래밍 언어의 구분은 시스템 자원을 접근해서 얻을 수 있느냐 → 그래서 HTML은 프로그래밍 언어가 아님
- 동일한 변수에 재할당 할 때는 복합연산자를 사용하는 것이 좋음 ⇒ 깔끔
- 같은지 같지 않은지 문자열 비교 연산이 가능함!
### 논리연산자
- 단축평가
<img src="https://hackmd.io/_uploads/HkjBKfD4n.png" width=150>

- and는 빡빡한 친구, 둘 다 true 무조건 둘 다 확인해봐야 함 → 3, 4를 만족하면 4까지 봐야 함, 반면 왼쪽에 0이 들리기 때문에 볼 필요가 없으므로 0
- or은 너그러운 친구, 둘 중 하나만 true한 값을 가지고 있으면 됨 → 왼쪽에 4를 가지고 있으면 오른쪽에 3이 있으면 4까지 보게 함
- map 내의 Index가 존재하는지 여부를 확인하기 위해 사용함
- 여기서 말하는 true한 값? 뭐지?
